---
title: "Misc"
author: "Jakub Nowosad"
format: html
---

```{r}
#| message: false
#| warning: false
spain = sf::read_sf("data/spain.gpkg")
covariates = terra::rast("data/predictors.tif")
temperature = sf::read_sf("data/temp_train.gpkg")

temperature = terra::extract(covariates, temperature, bind = TRUE) |> 
  sf::st_as_sf()
```

# RandomForestsGLS

```{r}
# library(RandomForestsGLS)
# ?RFGLS_estimate_spatial #(for estimation in spatial data)
# ?RFGLS_predict #(for prediction of mean function)
# ?RFGLS_predict_spatial #(for prediction of Spatial Response)
library(RandomForestsGLS)

coords = sf::st_coordinates(temperature)
temp_response = temperature$temp

temperature_df = sf::st_drop_geometry(temperature)
covariates = colnames(temperature_df)[2:(ncol(temperature_df) - 7)]
covariate_matrix = as.matrix(temperature_df[, covariates])

set.seed(2025-01-30)
train_idx = 1:floor(nrow(coords) * 0.8)
test_idx = (floor(nrow(coords) * 0.8) + 1):nrow(coords)

estimation_result = RFGLS_estimate_spatial(
  coords = coords[train_idx, ],
  y = temp_response[train_idx],
  X = covariate_matrix[train_idx, ],
  ntree = 50
)

prediction_result = RFGLS_predict(
  RFGLS_out = estimation_result,
  Xtest = covariate_matrix[test_idx, ]
)

prediction_result_spatial = RFGLS_predict_spatial(
  RFGLS_out = estimation_result,
  coords.0 = coords[test_idx, ],
  Xtest = covariate_matrix[test_idx, ]
)

print(prediction_result)
```

# spatialRF

```{r}
library(spatialRF)
library(sf)

# Prepare spatialRF data
spatial_data = st_drop_geometry(temperature)
distance_matrix = as.matrix(dist(spatial_data[2:(ncol(spatial_data))]))
coordinates = st_coordinates(temperature)
spatial_data$x = coordinates[, 1]
spatial_data$y = coordinates[, 2]

dependent.variable.name = "temp"
predictor.variable.names = colnames(spatial_data)[2:(ncol(spatial_data) - 9)]

# hengl method
rf_spatial_hengl = rf_spatial(
  data = spatial_data,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  method = "hengl",
  n.cores = 1
)
print(rf_spatial_hengl)

# mem.moran.sequential method
rf_spatial_moran = rf_spatial(
  data = spatial_data,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  method = "mem.moran.sequential",
  n.cores = 1
)
print(rf_spatial_moran)

# Fit an rf model first
rf_model = rf(
  data = spatial_data,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance_matrix,
  distance.thresholds = 0,
  n.cores = 1,
  verbose = FALSE
)

# Convert rf model to spatial model
rf_spatial_model = rf_spatial(model = rf_model)
```


# ENMeval

<https://jamiemkass.github.io/ENMeval/articles/ENMeval-2.0-vignette.html>

```{r}
library(ENMeval)
```

# sperrorest

```{r}
library(sperrorest)
library(rpart)

dependent.variable.name = "temp"
temperature_df = sf::st_drop_geometry(temperature)
temperature_df$x = temperature_df$X
temperature_df$y = temperature_df$Y
covariates = colnames(temperature_df)[2:(ncol(temperature_df) - 7)]

fo = as.formula(paste(dependent.variable.name, "~", paste(covariates, collapse = " + ")))
ctrl = rpart.control(cp = 0.005)

mypred_part = function(object, newdata) {
  predict(object, newdata)  # for regression
}

# Non-spatial cross-validation
nsp_res = sperrorest(
  data = temperature_df,
  formula = fo,
  model_fun = rpart,
  model_args = list(control = ctrl),
  pred_fun = mypred_part,
  smp_fun = partition_cv,
  smp_args = list(repetition = 1:2, nfold = 3),
  progress = TRUE
)
summary(nsp_res$error_rep)
summary(nsp_res$error_fold)

# Spatial cross-validation
sp_res = sperrorest(
  data = temperature_df,
  formula = fo,
  model_fun = rpart,
  model_args = list(control = ctrl),
  pred_fun = mypred_part,
  smp_fun = partition_kmeans,
  smp_args = list(repetition = 1:2, nfold = 3),
  progress = TRUE
)
summary(sp_res$error_rep)
summary(sp_res$error_fold)

library(ggplot2)

# Extract train/test RMSE from non-spatial CV
nsp_test_rmse = unlist(summary(nsp_res$error_rep, level = 1)$test_rmse)
nsp_train_rmse = unlist(summary(nsp_res$error_rep, level = 1)$train_rmse)

# Extract train/test RMSE from spatial CV
sp_test_rmse = unlist(summary(sp_res$error_rep, level = 1)$test_rmse)
sp_train_rmse = unlist(summary(sp_res$error_rep, level = 1)$train_rmse)

# Build data frames
nsp_df = data.frame(
  CV_Type = "Non-Spatial",
  Set = rep(c("Train", "Test"), each = length(nsp_train_rmse)),
  RMSE = c(nsp_train_rmse, nsp_test_rmse)
)
sp_df = data.frame(
  CV_Type = "Spatial",
  Set = rep(c("Train", "Test"), each = length(sp_train_rmse)),
  RMSE = c(sp_train_rmse, sp_test_rmse)
)

rmse_df = rbind(nsp_df, sp_df)

# Boxplot: training vs testing, non-spatial vs spatial
ggplot(rmse_df, aes(x = CV_Type, y = RMSE, fill = Set)) +
  geom_boxplot(position = position_dodge(0.8)) +
  theme_minimal() +
  labs(title = "RMSE Comparison", x = "CV Method", y = "RMSE")
```

# blockCV

<https://cran.r-project.org/web/packages/blockCV/vignettes/tutorial_2.html>

```{r}
library(blockCV)
```

# sits

<https://github.com/e-sensing/sits>

Out-of-scope